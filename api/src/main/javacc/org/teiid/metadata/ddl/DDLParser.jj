options {
	STATIC = false;
	ERROR_REPORTING = true;
	JAVA_UNICODE_ESCAPE = true;
	UNICODE_INPUT = false;
	IGNORE_CASE = true;
	DEBUG_PARSER = false;
	DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(DDLParser)

package org.teiid.metadata.ddl;

import java.util.*;
import org.teiid.metadata.*;
import org.teiid.connector.*;
import org.teiid.translator.*;

/** 
 * <p>The DDLParser is a JavaCC-generated parser that reads a SQL string and produces a 
 * Query object.  The SQLParser.java file is generated by JavaCC from the DDLParser.jj
 * file.  <B>WARNING:</B> DO NOT MODIFY the DDLParser.java file as it will be 
 * regenerated from the .jj file and your changes will be lost!</p>
 */
@SuppressWarnings("nls")
public class DDLParser extends DDLParserUtil {
} // end class

PARSER_END(DDLParser)

TOKEN_MGR_DECLS : 
{
    int commentNestingDepth; 
} 

SKIP :
{
	" " | "\t" | "\n" | "\r"
}

MORE :
{
  "/*" { commentNestingDepth = 1 ; } : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
MORE : 
{  
  "/*" { commentNestingDepth += 1 ; } 
} 

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN : 
{  
  "*/" { 
    commentNestingDepth -= 1;
    SwitchTo( commentNestingDepth==0 ? DEFAULT : IN_MULTI_LINE_COMMENT ) ; 
  }
} 

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN: /* Data types */
{
	<STRING: "string">
|   <VARBINARY: "varbinary">
|   <VARCHAR: "varchar">
|	<BOOLEAN: "boolean">
|	<BYTE: "byte">
|   <TINYINT: "tinyint">
|	<SHORT: "short">
|   <SMALLINT: "smallint">
|	<CHAR: "char">
|	<INTEGER: "integer">
|	<LONG: "long">
|   <BIGINT: "bigint">
|	<BIGINTEGER: "biginteger">
|	<FLOAT: "float">
|   <REAL: "real"> 
|	<DOUBLE: "double">
|	<BIGDECIMAL: "bigdecimal">
|   <DECIMAL: "decimal">
|	<DATE: "date">
|	<TIME: "time">
|	<TIMESTAMP: "timestamp">
|	<OBJECT: "object">
|	<BLOB: "blob">
|	<CLOB: "clob">
|	<XML: "xml">
}

TOKEN : /* Reserved words */
{
    <ALTER:  "alter">
|   <ACCESS_PATTERN: "accesspattern">
|   <AS: "as">
|   <AUTO_INCREMENT: "auto_increment">
|   <CONSTRAINT: "constraint">
|   <CREATE: "create">
|   <DEFAULT_KEYWORD: "default">
|   <FOREIGN: "foreign">
|   <FUNCTION: "function">
|   <IN: "in">
|   <INOUT: "inout">
|   <INSTEAD: "instead">
|   <INDEX: "index">
|   <NOT: "not">
|   <NULL: "null">
|   <OPTIONS: "options">
|   <OUT: "out">
|   <PRIMARY: "primary">
|   <PROCEDURE: "procedure">
|   <PUSHDOWN: "pushdown">
|   <RETURNS: "returns">
|   <REFERENCES: "references">
|   <TABLE:  "table">
|   <TRIGGER: "trigger">
|   <UNIQUE: "unique">
|   <VARARG: "vararg">
|   <VIEW:   "view">
|   <VIRTUAL: "virtual">

}

TOKEN : /* User variables and literals */
{
    < ALL_IN_GROUP: <ID> <PERIOD> <STAR> >

|   < ID: <QUOTED_ID> (<PERIOD> <QUOTED_ID>)* >
|	< #QUOTED_ID: <ID_PART> | ("\"" (("\"\"") | ~["\""] )+ "\"") >           
|   < #ID_PART: (("@" | "#" | <LETTER>) (<LETTER> | "_" | <DIGIT>)*) >               

| 	< DATETYPE: "{" "d" >
| 	< TIMETYPE: "{" "t" >
| 	< TIMESTAMPTYPE: "{" "ts" >
| 	< BOOLEANTYPE: "{" "b" >
|   < POS_REF: ["$"] (<DIGIT>)+ >
|	< INTEGERVAL: (<MINUS>)?(<DIGIT>)+ >
|   < DECIMALVAL: (<MINUS>)? (<DIGIT>)* <PERIOD> (<DIGIT>)+ >
|   < FLOATVAL: (<MINUS>)? <DIGIT> <PERIOD> (<DIGIT>)+ 
				["e", "E"] (["+","-"])? (<DIGIT>)+  >
|   < STRINGVAL: (("N"|"E")? "'" ( ("''") | ~["'"] )* "'") >
|	< #LETTER: (["a"-"z","A"-"Z"] | ["\u0153"-"\ufffd"]) >
|	< #DIGIT: ["0"-"9"] >
|   < BINARYSTRINGVAL: ("X"|"x" "'" ( <HEXIT><HEXIT> )+ "'") >
|	< #HEXIT: (["a"-"f","A"-"F"] | <DIGIT> ) >
}

TOKEN : /* Punctuation */
{
	<COMMA: ",">
|	<PERIOD: ".">
|	<LPAREN: "(">
|	<RPAREN: ")">
|   <LBRACE: "{">
|   <RBRACE: "}">
|   <LSBRACE: "[">
|   <RSBRACE: "]">
|	<EQ: "=">
|	<NE: "<>">
|	<NE2: "!=">
|	<LT: "<">
|	<LE: "<=">
|	<GT: ">">
|	<GE: ">=">
|	<STAR: "*">
|	<SLASH: "/">
|	<PLUS: "+">
|	<MINUS: "-">
|   <QMARK: "?">
|   <DOLLAR: "$">
|   <SEMICOLON: ";">
|   <COLON: ":">
|	<CONCAT_OP: "||">
}


//----------------------------------------------------
//----------------------------------------------------

String stringVal() :
{
	Token t = null;	
}
{
  	(t = <STRINGVAL>)
  	{
  		return normalizeStringLiteral(t.image);
  	}
}

String id() :
{
	Token t = null;
}
{
  	(t = <ID>)
  	{
  		return normalizeId(t.image);
  	}
}


void getMetadata(MetadataFactory factory) throws TranslatorException :
{
}
{
    ddlStmts(factory) (<SEMICOLON> ddlStmts(factory))*
}

void ddlStmts(MetadataFactory factory) throws TranslatorException :
{
}
{
	(LOOKAHEAD(3) 	createTable(factory) | 
	 LOOKAHEAD(4)   createFunction (factory) | 
	 LOOKAHEAD(3)	createProcedure(factory) |
	 LOOKAHEAD(4) 	createTrigger(factory)
	)
}

void createFunction(MetadataFactory factory) throws TranslatorException :
{
	boolean pushdown = false;
	String dataTypeString = null;
	FunctionMethod func = null;
	List<FunctionParameter> ins  = new ArrayList<FunctionParameter>();
	FunctionParameter in = null;
	String funcName = null;
}
{	
	<CREATE> [<PUSHDOWN> {pushdown = true;}] <FUNCTION>
	funcName = id()
	{
		func = factory.addFunction(funcName);		
	}
	<LPAREN>
	[in = readFunctionParameter()]
	{
		if (in != null){
			ins.add(in);
		}
	}
	(<COMMA> 
		(in = readFunctionParameter())
		{
			ins.add(in);
		}
	)*	
	<RPAREN>
	<RETURNS>	dataTypeString = dataTypeString()
    [<OPTIONS> <LPAREN>
	   readFunctionOption(func)
	   (<COMMA>
		readFunctionOption(func)
	   )*	   
	   <RPAREN>
	]	
	{
		if (pushdown){
			func.setPushdown(FunctionMethod.PushDown.MUST_PUSHDOWN);
		}
		func.setOutputParameter(new FunctionParameter(FunctionParameter.OUTPUT_PARAMETER_NAME, dataTypeString));
		func.setInputParameters(ins);
	}
}

Procedure createProcedure(MetadataFactory factory) throws TranslatorException :
{
	boolean virtual = false;
	Procedure proc = null;
	String procName = null;
}
{
	<CREATE> [<VIRTUAL> {virtual = true;}] <PROCEDURE>
	procName = id()
	{
		proc = factory.addProcedure(procName);		
	}

	<LPAREN>
	[readProcedureParameter(factory, proc)]
	(<COMMA> readProcedureParameter(factory, proc))*	
	<RPAREN>
	
	<RETURNS> readProcedureReturn(factory, proc)
	
    [<OPTIONS> <LPAREN>
	   readProcedureOption(proc)
	   (<COMMA>
		readProcedureOption(proc)
	   )*	   
	   <RPAREN>
	]
	<AS>
	{
		proc.setVirtual(virtual);
		proc.setFunction(false);
		return proc;
	}
}

void readProcedureParameter(MetadataFactory factory, Procedure proc) throws TranslatorException :
{
	String name = null;
	String type = null;
	Token direction = null;
}
{
	[((direction = <IN>)|(direction=<OUT>)|(direction=<INOUT>))]
	name = id()
	type = dataTypeString()
	{
		ProcedureParameter.Type ppType = ProcedureParameter.Type.In;
		
		if (direction == null){
			ppType = ProcedureParameter.Type.In;
		}
		else if (direction.image.equalsIgnoreCase("in")){
			ppType = ProcedureParameter.Type.In ;
		}
		else if (direction.image.equalsIgnoreCase("out")){
			ppType = ProcedureParameter.Type.Out;
		}
		else if (direction.image.equalsIgnoreCase("inout")){
			ppType = ProcedureParameter.Type.InOut;
		}
		else {
			throw new ParseException("Unknown type of parameter on procedure "+ proc.getName());
		}
		factory.addProcedureParameter(name, type, ppType, proc);
	}
}

void readProcedureReturn(MetadataFactory factory, Procedure proc) throws TranslatorException :
{
	String name = null;
	String type = null;
}
{
	<LPAREN>
	  name = id()
	  type = dataTypeString()
	  {
	  	factory.addProcedureResultSetColumn(name, type, proc);
	  }
	  (<COMMA> 
	  	name = id()
	    type = dataTypeString()
		{
			factory.addProcedureResultSetColumn(name, type, proc);
		}
	  )*
	 <RPAREN> 
}

void createTrigger(MetadataFactory factory)  throws TranslatorException:
{
}
{
	<CREATE> <TRIGGER>
}

void createTable(MetadataFactory factory) throws TranslatorException :
{
	Table table = null;
	String tableName = null;
	boolean view = false;
	String queryPlan = null;
}
{
	<CREATE> (<FOREIGN> <TABLE> | <VIEW> {view = true;}) 
	tableName = id()
	<LPAREN>
	{
	    table = factory.addTable(tableName);
	    table.setVirtual(view);
	}
    createColumn(factory, table)
    (LOOKAHEAD(2) <COMMA>
      createColumn(factory, table)
    )*	
    [LOOKAHEAD(2) <COMMA> (readPrimaryKeys(table) | readConstraints(table) | readForeignKeys(factory, table))
        (<COMMA>
         (readConstraints(table)|readForeignKeys(factory, table))
        )*
    ]    
    <RPAREN>    
    [<OPTIONS> <LPAREN>
	   readTableOption(table)
	   (<COMMA>
		readTableOption(table)
	   )*	   
	   <RPAREN>
	]
	[<AS> queryPlan = id()]
	{
		if (view && queryPlan == null){
			throw new ParseException("View definition must have query plan defined");
		}
		
		if (view){
			table.setSelectTransformation(queryPlan);
		}
	}
}

void readForeignKeys(MetadataFactory factory, Table table) :
{
	ForeignKey fk = null;
	Column column = null;
	String viewName = null;
	Table reference = null;
	KeyRecord pk = null;
}
{
	<FOREIGN> nonReserved("KEY")
    {
	    fk = new ForeignKey();
	    for (String col: getColumnNames()) {
	    	column = getColumn(col, table);
	    	if (column == null) {
	    		throw new ParseException("Column name "+ col + " not found in table "+ table.getName());
	    	}
	    	fk.addColumn(column);
	    }	    	    
    }
    <REFERENCES>
    viewName = id()
    {
    	pk = new KeyRecord(KeyRecord.Type.Primary);
    	reference = getTable(viewName, factory.getMetadataStore());
	    for (String col: getColumnNames()) {
	    	column = getColumn(col, reference);
	    	if (column == null) {
	    		throw new ParseException("Column name "+ col + " not found in table "+ reference.getName() +" that is being referenced in foreign key on "+ table.getName());
	    	}
	    	pk.addColumn(column);
	    }
	    fk.setPrimaryKey(pk);
	    table.getForeignKeys().add(fk);    
    }
}

void readPrimaryKeys(Table table) :
{
	KeyRecord keyrecord = null;
	Column column = null;
}
{
	<PRIMARY> nonReserved("KEY")
    {
	    keyrecord = new KeyRecord(KeyRecord.Type.Primary);
	    for (String col: getColumnNames()) {
	    	column = getColumn(col, table);
	    	if (column == null) {
	    		throw new ParseException("Column name "+ col + " not found in table "+ table.getName());
	    	}
	    	keyrecord.addColumn(column);
	    }
	    if (table.getPrimaryKey() == null)
	 		table.setPrimaryKey(keyrecord);
	 	else
	 		throw new ParseException("Primary Key is already defined on "+ table.getName());
    }
}

void readConstraints(Table table) :
{
	KeyRecord keyrecord = null;
	Column column = null;
	boolean index = false;
	boolean unique = false;
	boolean ap = false;
	Token type = null;
}
{
	(<INDEX> { index = true; } |<UNIQUE> { unique = true; } | <ACCESS_PATTERN> { ap = true; } )
    {
    	if (index) { keyrecord = new KeyRecord(KeyRecord.Type.Index); }
    	if (unique) { keyrecord = new KeyRecord(KeyRecord.Type.Unique); }	    
    	if (ap) { keyrecord = new KeyRecord(KeyRecord.Type.AccessPattern); }	    
	    
	    for (String col: getColumnNames()) {
	    	column = getColumn(col, table);
	    	if (column == null) {
	    		throw new ParseException("Column name "+ col + " not found in table "+ table.getName());
	    	}
	    	keyrecord.addColumn(column);
	    }
	    
    	if (index) { table.getIndexes().add(keyrecord); }
    	if (unique) { table.getUniqueKeys().add(keyrecord); }	    
    	if (ap) { table.getAccessPatterns().add(keyrecord); }	    
    }
}

ArrayList<String> getColumnNames() :
{
	ArrayList list = new ArrayList<String>();
	String id = null;
}
{
	<LPAREN>
	  id = id()
	  {
	  	list.add(id);
	  }
	  (<COMMA> id = id()
	   {
		list.add(id);
	   }
	  )*
	 <RPAREN> 
	 {
	 	return list;
	 }
}

void createColumn(MetadataFactory factory, Table table) throws TranslatorException :
{
	String element = null;
	String type = null;
	boolean autoIncrement = false;
	boolean notNull = false;
	String defalt = null;
	KeyRecord unique = null;
	KeyRecord index = null;
	KeyRecord pk = null;
	Column column = null;
}
{
	 element = id()
	 (
	  type = dataTypeString()
	  {
    	column = factory.addColumn(validateElementName(element), type, table);
	  }
	 )
	 [<NOT> <NULL> { notNull = true; }]
	 [<AUTO_INCREMENT> { autoIncrement = true; }]	 
	 ([(<UNIQUE> 
	   {
	   unique = new KeyRecord(KeyRecord.Type.Unique);
	   unique.addColumn(column);
	   table.getUniqueKeys().add(unique);
	   })
	  |(<INDEX>
	   {
	   index = new KeyRecord(KeyRecord.Type.Index);
	   index.addColumn(column);
	   table.getIndexes().add(index);
	   })	 
	 |(<PRIMARY> nonReserved("KEY")
	   {
	   pk = new KeyRecord(KeyRecord.Type.Primary);
	   pk.addColumn(column);
	   if (table.getPrimaryKey() == null)
	   	table.setPrimaryKey(pk);
	   else
	     throw new ParseException("Primary Key is already defined on "+ table.getName());
	   })	 
	 ])
	 [<DEFAULT_KEYWORD> defalt = stringVal()]
	 [<OPTIONS> <LPAREN>
	   readColumnOption(column)
	   (<COMMA>
		readColumnOption(column)
	   )*	   
	   <RPAREN>
	 ]
	 {
	    column.setAutoIncremented(autoIncrement);
	    column.setNullType(notNull?Column.NullType.No_Nulls:Column.NullType.Nullable);
	    if (defalt != null){
	    	column.setDefaultValue(defalt);
	    }
	 }
}

void readColumnOption(Column column) :
{
	Token value = null;
	String key = null;
}
{
	 key = id()
	 ((value = <STRINGVAL>)
	 { 
	 	setColumnOption(column, key, normalizeStringLiteral(value.image)); 
	 } 
	 | (value = <INTEGERVAL>) 
	 { 
	 	setColumnOption(column, key, value.image); 
	 }
	 | (value = <DECIMALVAL>)
	 { 
	 	setColumnOption(column, key, value.image); 
	 })
}

void readFunctionOption(FunctionMethod fm) :
{
	Token value = null;
	String key = null;
}
{
	 key = id()
	 ((value = <STRINGVAL>)
	 { 
	 	setFunctionOption(fm, key, normalizeStringLiteral(value.image)); 
	 } 
	 | (value = <INTEGERVAL>) 
	 { 
	 	setFunctionOption(fm, key, value.image); 
	 }
	 | (value = <DECIMALVAL>)
	 { 
	 	setFunctionOption(fm, key, value.image); 
	 })
}

void readProcedureOption(Procedure proc) :
{
	Token value = null;
	String key = null;
}
{
	 key = id()
	 ((value = <STRINGVAL>)
	 { 
	 	setProcedureOption(proc, key, normalizeStringLiteral(value.image)); 
	 } 
	 | (value = <INTEGERVAL>) 
	 { 
	 	setProcedureOption(proc, key, value.image); 
	 }
	 | (value = <DECIMALVAL>)
	 { 
	 	setProcedureOption(proc, key, value.image); 
	 })
}

void readTableOption(Table table) :
{
	Token value = null;
	String key = null;
}
{
	 key = id()
	 ((value = <STRINGVAL>)
	 { 
	 	setTableOption(table, key, normalizeStringLiteral(value.image)); 
	 } 
	 | (value = <INTEGERVAL>) 
	 { 
	 	setTableOption(table, key, value.image); 
	 }
	 | (value = <DECIMALVAL>)
	 { 
	 	setTableOption(table, key, value.image); 
	 })
}

FunctionParameter readFunctionParameter() :
{
	String name = null;
	String type = null;
	Token vararg = null;
}
{
	name = id()
	type = dataTypeString()
	[vararg = <VARARG>]
	{
		return new FunctionParameter(name, type, "", (vararg != null));
	}
}

String dataTypeString() : 
{
	Token typeToken = null;
}
{
	(
		typeToken = <VARCHAR> | 
		typeToken = <BOOLEAN> | 
		typeToken = <BYTE> | 
		typeToken = <SMALLINT> |
		typeToken = <CHAR> | 
		typeToken = <INTEGER> | 
		typeToken = <LONG> | 
		typeToken = <FLOAT> |
		typeToken = <REAL> | 
		typeToken = <DOUBLE> | 
		typeToken = <DECIMAL> | 
		typeToken = <DATE> | 
		typeToken = <TIME> |
		typeToken = <TIMESTAMP> |
		typeToken = <OBJECT> |
		typeToken = <BLOB> |
		typeToken = <CLOB> |
		typeToken = <VARBINARY> |
		typeToken = <XML>
		
	)
	{
		return typeToken.image;
	}
}

String nonReserved(String... expected) :
{
	Token t = null;
}
{
	t = <ID> 
	{
		String result = matchesAny(t.image, expected);
		if (result != null) {
			return result;
		}
		throw new ParseException(DataPlugin.Util.getString("SQLParser.expected_non_reserved", Arrays.toString(expected), t.image));
	}
}
